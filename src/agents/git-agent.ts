// ============================================================
// QIA — Git Agent
// Auto branch, commit, push, PR via GitHub API
// ============================================================

import { execSync } from 'child_process';
import { Octokit } from '@octokit/rest';
import chalk from 'chalk';
import { agentConfig } from '../config/agent.config.js';
import type { GeneratedTest, PullRequestInfo } from '../types/index.js';

export class GitAgent {
  private readonly octokit: Octokit;
  private readonly branch: string;

  constructor(ticketKey: string) {
    this.octokit = new Octokit({ auth: agentConfig.githubToken });
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    this.branch = `qia/${ticketKey.toLowerCase()}-${timestamp}`;
  }

  async commitAndPush(tests: GeneratedTest[], ticketKey: string): Promise<PullRequestInfo> {
    console.log(chalk.cyan(`\n[GitAgent] Preparing git operations...`));

    this.createBranch();
    this.stageAndCommit(tests, ticketKey);
    this.pushBranch();
    const pr = await this.createPullRequest(ticketKey, tests);

    console.log(chalk.green(`[GitAgent] PR created: ${pr.url}`));
    return pr;
  }

  private createBranch(): void {
    try {
      this.git(`checkout -b ${this.branch}`);
      console.log(chalk.gray(`  Created branch: ${this.branch}`));
    } catch {
      // Branch might exist
      this.git(`checkout ${this.branch}`);
    }
  }

  private stageAndCommit(tests: GeneratedTest[], ticketKey: string): void {
    const filePaths = tests.map(t => t.filePath).join(' ');
    this.git(`add ${filePaths} .qia/dna-profile.json`);

    const message = [
      `feat(qia): ${ticketKey} — AI-generated tests`,
      '',
      `Generated by QIA (Quality Intelligence Agent)`,
      `Ticket: ${ticketKey}`,
      `Test files: ${tests.length}`,
      `Total scenarios: ${tests.reduce((sum, t) => sum + t.scenarioCount, 0)}`,
      `Types: ${[...new Set(tests.map(t => t.type))].join(', ')}`,
      '',
      'Auto-generated by QIA — Do not edit manually',
    ].join('\n');

    this.git(`commit -m "${message.replace(/"/g, "'")}"`);
    console.log(chalk.gray(`  Committed ${tests.length} test files`));
  }

  private pushBranch(): void {
    this.git(`push origin ${this.branch} --set-upstream`);
    console.log(chalk.gray(`  Pushed branch: ${this.branch}`));
  }

  private async createPullRequest(ticketKey: string, tests: GeneratedTest[]): Promise<PullRequestInfo> {
    const testList = tests
      .map(t => `- \`${t.filePath}\` (${t.scenarioCount} tests, ${t.type})`)
      .join('\n');

    const body = `## QIA — AI-Generated Tests for ${ticketKey}

> Auto-generated by [QIA — Quality Intelligence Agent](https://github.com/${agentConfig.githubOwner}/${agentConfig.githubRepo})

### What's included
${testList}

### Test Coverage
- Framework DNA scanned and matched
- Self-healing locators (3-tier: testid → semantic → AI)
- Allure reporting with full tagging
- Visual regression baselines created

### CI
GitHub Actions will run 4 parallel shards automatically.

### Review Checklist
- [ ] Locators look correct for the codebase
- [ ] Assertions match acceptance criteria
- [ ] No hardcoded credentials or sensitive data
- [ ] Tests are deterministic (no flakiness)

---
*Generated by QIA on ${new Date().toISOString()}*`;

    const response = await this.octokit.rest.pulls.create({
      owner: agentConfig.githubOwner,
      repo: agentConfig.githubRepo,
      title: `QIA: ${ticketKey} — AI-generated tests`,
      body,
      head: this.branch,
      base: process.env['GITHUB_DEFAULT_BRANCH'] ?? 'main',
      draft: false,
    });

    return {
      number: response.data.number,
      url: response.data.html_url,
      branch: this.branch,
      title: response.data.title,
      sha: response.data.head.sha,
    };
  }

  private git(command: string): string {
    try {
      return execSync(`git ${command}`, { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'] });
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      throw new Error(`Git command failed: git ${command}\n${msg}`);
    }
  }
}
